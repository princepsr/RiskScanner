// Risk Scanner - Vulnerability Table Component

class VulnerabilityTableComponent {
  constructor(options = {}) {
    this.options = {
      containerId: options.containerId || 'vulnerabilityTable',
      pageSize: options.pageSize || 25,
      sortable: options.sortable !== false,
      filterable: options.filterable !== false,
      onRowClick: options.onRowClick || null,
      onSort: options.onSort || null,
      onFilter: options.onFilter || null,
      ...options
    };
    
    this.container = null;
    this.table = null;
    this.tbody = null;
    this.thead = null;
    this.data = [];
    this.filteredData = [];
    this.currentPage = 1;
    this.sortColumn = null;
    this.sortDirection = 'asc';
    this.filters = {};
    
    this.init();
  }

  init() {
    this.setupElements();
    this.setupEventListeners();
  }

  setupElements() {
    this.container = DOMUtils.$(this.options.containerId);
    if (!this.container) {
      console.error(`Vulnerability table container not found: ${this.options.containerId}`);
      return;
    }
    
    this.table = this.container.querySelector('table');
    this.tbody = this.table.querySelector('tbody');
    this.thead = this.table.querySelector('thead');
    
    if (!this.table || !this.tbody || !this.thead) {
      console.error('Table structure not found');
      return;
    }
  }

  setupEventListeners() {
    if (!this.options.sortable) return;
    
    // Setup sortable columns
    const sortableHeaders = this.thead.querySelectorAll('.table-sortable');
    sortableHeaders.forEach(header => {
      DOMUtils.on(header, 'click', () => {
        const column = header.getAttribute('data-sort');
        this.sort(column);
      });
    });
    
    // Setup filter inputs
    if (this.options.filterable) {
      this.setupFilters();
    }
  }

  setupFilters() {
    const searchInput = DOMUtils.$('tableSearch');
    const severityFilter = DOMUtils.$('severityFilter');
    const confidenceFilter = DOMUtils.$('confidenceFilter');
    
    if (searchInput) {
      DOMUtils.on(searchInput, 'input', (e) => {
        this.filters.search = e.target.value;
        this.applyFilters();
      });
    }
    
    if (severityFilter) {
      DOMUtils.on(severityFilter, 'change', (e) => {
        this.filters.severity = e.target.value;
        this.applyFilters();
      });
    }
    
    if (confidenceFilter) {
      DOMUtils.on(confidenceFilter, 'change', (e) => {
        this.filters.confidence = e.target.value;
        this.applyFilters();
      });
    }
  }

  render(data) {
    this.data = data || [];
    this.filteredData = [...this.data];
    this.currentPage = 1;
    this.renderTable();
    this.renderPagination();
  }

  renderScanResults(data) {
    // Render scan results (dependencies without vulnerabilities)
    this.data = data || [];
    this.filteredData = [...this.data];
    this.currentPage = 1;
    this.renderScanTable();
  }

  renderTable() {
    if (!this.tbody) return;
    
    // Clear existing rows
    DOMUtils.empty(this.tbody);
    
    if (this.filteredData.length === 0) {
      this.renderEmptyState();
      return;
    }
    
    // Calculate pagination
    const startIndex = (this.currentPage - 1) * this.options.pageSize;
    const endIndex = startIndex + this.options.pageSize;
    const pageData = this.filteredData.slice(startIndex, endIndex);
    
    // Render rows
    pageData.forEach((item, index) => {
      const row = this.createRow(item, startIndex + index);
      DOMUtils.append(this.tbody, row);
    });
  }

  renderScanTable() {
    if (!this.tbody) return;
    
    // Clear existing rows
    DOMUtils.empty(this.tbody);
    
    if (this.filteredData.length === 0) {
      this.renderEmptyState('No dependencies found');
      return;
    }
    
    // Render dependency rows
    this.filteredData.forEach((item, index) => {
      const row = this.createScanRow(item, index);
      DOMUtils.append(this.tbody, row);
    });
  }

  createRow(item, index) {
    const row = DOMUtils.createElement('tr');
    
    // Dependency column
    const depCell = DOMUtils.createElement('td', {
      className: 'dependency-cell',
      innerHTML: this.formatDependency(item.dependency)
    });
    
    // Risk column
    const riskCell = DOMUtils.createElement('td');
    const riskPill = this.createSeverityPill(item.riskLevel || item.severity);
    DOMUtils.append(riskCell, riskPill);
    
    // Score column
    const scoreCell = DOMUtils.createElement('td');
    if (item.riskScore !== undefined && item.riskScore !== null) {
      const riskScore = this.formatRiskScore(item.riskScore);
      scoreCell.innerHTML = riskScore.html;
    } else {
      scoreCell.textContent = 'N/A';
    }
    
    // Confidence column
    const confidenceCell = DOMUtils.createElement('td');
    if (item.confidenceLevel) {
      const confidencePill = this.createConfidencePill(item.confidenceLevel);
      DOMUtils.append(confidenceCell, confidencePill);
    } else {
      confidenceCell.textContent = 'N/A';
    }
    
    // Vulnerability column
    const vulnCell = DOMUtils.createElement('td', {
      className: 'vulnerability-cell',
      innerHTML: this.formatVulnerability(item.vulnerability)
    });
    
    // AI Explanation column
    const aiCell = DOMUtils.createElement('td', {
      className: 'ai-explanation'
    });
    
    if (item.aiExplanation) {
      const toggleBtn = DOMUtils.createElement('button', {
        className: 'ai-explanation__toggle',
        textContent: 'View AI Analysis'
      });
      
      const content = DOMUtils.createElement('div', {
        className: 'ai-explanation__content hidden',
        textContent: item.aiExplanation
      });
      
      DOMUtils.on(toggleBtn, 'click', () => {
        DOMUtils.toggleClass(content, 'hidden');
        toggleBtn.textContent = DOMUtils.hasClass(content, 'hidden') ? 'View AI Analysis' : 'Hide AI Analysis';
      });
      
      DOMUtils.append(aiCell, toggleBtn);
      DOMUtils.append(aiCell, content);
    } else {
      aiCell.textContent = 'No AI analysis';
    }
    
    // Actions column
    const actionsCell = DOMUtils.createElement('td', {
      className: 'table-actions'
    });
    
    const suppressBtn = DOMUtils.createElement('button', {
      className: 'btn-icon',
      title: 'Suppress vulnerability',
      innerHTML: `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M18.364 18.364A9 9 0 005.636 5.636m12.728 0A9 9 0 0018.364 5.636M9 12a9 9 0 01-9 9m9-9a9 9 0 009 9m-9 9a9 9 0 01-9-9"/>
        </svg>
      `
    });
    
    const exportBtn = DOMUtils.createElement('button', {
      className: 'btn-icon',
      title: 'Export details',
      innerHTML: `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.707.293H19a2 2 0 012-2z"/>
        </svg>
      `
    });
    
    DOMUtils.on(suppressBtn, 'click', () => {
      this.suppressVulnerability(item);
    });
    
    DOMUtils.on(exportBtn, 'click', () => {
      this.exportVulnerability(item);
    });
    
    DOMUtils.append(actionsCell, suppressBtn);
    DOMUtils.append(actionsCell, exportBtn);
    
    // Add all cells to row
    DOMUtils.append(row, depCell);
    DOMUtils.append(row, riskCell);
    DOMUtils.append(row, scoreCell);
    DOMUtils.append(row, confidenceCell);
    DOMUtils.append(row, vulnCell);
    DOMUtils.append(row, aiCell);
    DOMUtils.append(row, actionsCell);
    
    // Add click handler
    if (this.options.onRowClick) {
      DOMUtils.on(row, 'click', () => {
        this.options.onRowClick(item);
      });
    }
    
    return row;
  }

  createScanRow(item, index) {
    const row = DOMUtils.createElement('tr');
    
    // Dependency column
    const depCell = DOMUtils.createElement('td', {
      className: 'dependency-cell',
      innerHTML: this.formatDependency(item)
    });
    
    // Build tool column
    const buildToolCell = DOMUtils.createElement('td');
    buildToolCell.textContent = item.buildTool || 'Unknown';
    
    // Version column
    const versionCell = DOMUtils.createElement('td');
    versionCell.textContent = item.version || 'N/A';
    
    // Scope column
    const scopeCell = DOMUtils.createElement('td');
    scopeCell.textContent = item.scope || 'N/A';
    
    // Actions column
    const actionsCell = DOMUtils.createElement('td', {
      className: 'table-actions'
    });
    
    const analyzeBtn = DOMUtils.createElement('button', {
      className: 'btn-icon',
      title: 'Analyze dependency',
      innerHTML: `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
        </svg>
      `
    });
    
    DOMUtils.on(analyzeBtn, 'click', () => {
      this.analyzeDependency(item);
    });
    
    DOMUtils.append(actionsCell, analyzeBtn);
    
    // Add all cells to row
    DOMUtils.append(row, depCell);
    DOMUtils.append(row, buildToolCell);
    DOMUtils.append(row, versionCell);
    DOMUtils.append(row, scopeCell);
    DOMUtils.append(row, actionsCell);
    
    return row;
  }

  createSeverityPill(severity) {
    const severityData = FormatUtils.formatSeverity(severity);
    return DOMUtils.createElement('span', {
      className: severityData.className,
      textContent: severityData.text
    });
  }

  createConfidencePill(confidence) {
    const confidenceData = FormatUtils.formatConfidence(confidence);
    return DOMUtils.createElement('span', {
      className: confidenceData.className,
      textContent: confidenceData.text
    });
  }

  formatDependency(dependency) {
    if (typeof dependency === 'string') {
      return `<span class="font-mono">${FormatUtils.escapeHtml(dependency)}</span>`;
    }
    
    const { groupId, artifactId, version } = dependency;
    return `
      <span class="dependency-cell__group">${FormatUtils.escapeHtml(groupId)}:</span>
      <span class="dependency-cell__artifact">${FormatUtils.escapeHtml(artifactId)}</span>
      <span class="dependency-cell__version">${FormatUtils.escapeHtml(version)}</span>
    `;
  }

  formatVulnerability(vulnerability) {
    if (!vulnerability) return 'N/A';
    
    const id = vulnerability.id || vulnerability.cveId || 'N/A';
    const title = vulnerability.title || vulnerability.description || 'N/A';
    
    return `
      <div class="vulnerability-cell__id">${FormatUtils.escapeHtml(id)}</div>
      <div class="vulnerability-cell__title">${FormatUtils.truncateText(title, 100)}</div>
    `;
  }

  formatRiskScore(score) {
    const riskData = FormatUtils.formatRiskScore(score);
    const percentage = riskData.percentage;
    
    let className = 'risk-score--low';
    if (percentage >= 70) className = 'risk-score--high';
    else if (percentage >= 40) className = 'risk-score--medium';
    
    return {
      html: `
        <div class="risk-score">
          <span class="risk-score__value">${percentage}</span>
          <div class="risk-score__bar">
            <div class="risk-score__fill" style="width: ${percentage}%"></div>
          </div>
        </div>
      `,
      className
    };
  }

  sort(column) {
    if (!this.options.sortable) return;
    
    if (this.sortColumn === column) {
      // Toggle direction
      this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
    } else {
      this.sortColumn = column;
      this.sortDirection = 'asc';
    }
    
    this.applySorting();
    this.renderTable();
    this.renderPagination();
    
    // Update sort indicators
    this.updateSortIndicators();
    
    if (this.options.onSort) {
      this.options.onSort(column, this.sortDirection);
    }
  }

  applySorting() {
    if (!this.sortColumn) return;
    
    this.filteredData.sort((a, b) => {
      let aVal = this.getSortValue(a, this.sortColumn);
      let bVal = this.getSortValue(b, this.sortColumn);
      
      // Handle string comparison
      if (typeof aVal === 'string') aVal = aVal.toLowerCase();
      if (typeof bVal === 'string') bVal = bVal.toLowerCase();
      
      let comparison = 0;
      if (aVal < bVal) comparison = -1;
      if (aVal > bVal) comparison = 1;
      
      return this.sortDirection === 'desc' ? -comparison : comparison;
    });
  }

  getSortValue(item, column) {
    switch (column) {
      case 'dependency':
        return item.dependency ? (item.dependency.artifactId || item.dependency) : '';
      case 'risk':
        return item.riskLevel || item.severity || '';
      case 'score':
        return item.riskScore || 0;
      case 'confidence':
        return item.confidenceLevel || '';
      default:
        return '';
    }
  }

  applyFilters() {
    this.filteredData = this.data.filter(item => {
      // Search filter
      if (this.filters.search) {
        const searchLower = this.filters.search.toLowerCase();
        const dependencyStr = item.dependency ? 
          `${item.dependency.groupId} ${item.dependency.artifactId} ${item.dependency.version}`.toLowerCase() : '';
        const vulnStr = item.vulnerability ? 
          `${item.vulnerability.id} ${item.vulnerability.title}`.toLowerCase() : '';
        
        if (!dependencyStr.includes(searchLower) && !vulnStr.includes(searchLower)) {
          return false;
        }
      }
      
      // Severity filter
      if (this.filters.severity) {
        const itemSeverity = item.riskLevel || item.severity || '';
        if (itemSeverity.toUpperCase() !== this.filters.severity.toUpperCase()) {
          return false;
        }
      }
      
      // Confidence filter
      if (this.filters.confidence) {
        const itemConfidence = item.confidenceLevel || '';
        if (itemConfidence.toUpperCase() !== this.filters.confidence.toUpperCase()) {
          return false;
        }
      }
      
      return true;
    });
    
    this.currentPage = 1;
    this.renderTable();
    this.renderPagination();
    
    if (this.options.onFilter) {
      this.options.onFilter(this.filters, this.filteredData.length);
    }
  }

  updateSortIndicators() {
    if (!this.thead) return;
    
    const headers = this.thead.querySelectorAll('.table-sortable');
    headers.forEach(header => {
      const column = header.getAttribute('data-sort');
      const icon = header.querySelector('.table-sort__icon');
      
      if (column === this.sortColumn) {
        DOMUtils.addClass(header, `table-sortable--${this.sortDirection}`);
        if (icon) {
          icon.style.transform = this.sortDirection === 'asc' ? 'rotate(0deg)' : 'rotate(180deg)';
        }
      } else {
        DOMUtils.removeClass(header, 'table-sortable--asc');
        DOMUtils.removeClass(header, 'table-sortable--desc');
        if (icon) {
          icon.style.transform = 'rotate(0deg)';
        }
      }
    });
  }

  renderEmptyState(message = 'No vulnerabilities found') {
    const row = DOMUtils.createElement('tr');
    const cell = DOMUtils.createElement('td', {
      colSpan: this.getColumnCount(),
      className: 'text-center text-muted',
      textContent: message
    });
    
    DOMUtils.append(row, cell);
    DOMUtils.append(this.tbody, row);
  }

  getColumnCount() {
    if (!this.thead) return 1;
    const headers = this.thead.querySelectorAll('th');
    return headers.length;
  }

  renderPagination() {
    const paginationContainer = DOMUtils.$('pagination');
    if (!paginationContainer) return;
    
    const totalPages = Math.ceil(this.filteredData.length / this.options.pageSize);
    const startItem = (this.currentPage - 1) * this.options.pageSize + 1;
    const endItem = Math.min(startItem + this.options.pageSize - 1, this.filteredData.length);
    
    // Update info
    const infoElement = paginationContainer.querySelector('.pagination__info');
    if (infoElement) {
      infoElement.textContent = `Showing ${startItem}-${endItem} of ${this.filteredData.length} items`;
    }
    
    // Update controls
    const controlsElement = paginationContainer.querySelector('.pagination__controls');
    if (controlsElement) {
      DOMUtils.empty(controlsElement);
      
      // Previous button
      const prevBtn = DOMUtils.createElement('button', {
        className: 'pagination__btn',
        textContent: 'Previous',
        disabled: this.currentPage === 1
      });
      
      DOMUtils.on(prevBtn, 'click', () => {
        if (this.currentPage > 1) {
          this.goToPage(this.currentPage - 1);
        }
      });
      
      DOMUtils.append(controlsElement, prevBtn);
      
      // Page numbers
      const maxButtons = 5;
      let startPage = Math.max(1, this.currentPage - Math.floor(maxButtons / 2));
      let endPage = Math.min(totalPages, startPage + maxButtons - 1);
      
      if (endPage - startPage < maxButtons - 1) {
        startPage = Math.max(1, endPage - maxButtons + 1);
      }
      
      for (let i = startPage; i <= endPage; i++) {
        const pageBtn = DOMUtils.createElement('button', {
          className: 'pagination__btn',
          textContent: i.toString(),
          disabled: i === this.currentPage
        });
        
        if (i === this.currentPage) {
          DOMUtils.addClass(pageBtn, 'pagination__btn--active');
        }
        
        DOMUtils.on(pageBtn, 'click', () => {
          this.goToPage(i);
        });
        
        DOMUtils.append(controlsElement, pageBtn);
      }
      
      // Next button
      const nextBtn = DOMUtils.createElement('button', {
        className: 'pagination__btn',
        textContent: 'Next',
        disabled: this.currentPage === totalPages
      });
      
      DOMUtils.on(nextBtn, 'click', () => {
        if (this.currentPage < totalPages) {
          this.goToPage(this.currentPage + 1);
        }
      });
      
      DOMUtils.append(controlsElement, nextBtn);
    }
  }

  goToPage(page) {
    this.currentPage = page;
    this.renderTable();
    this.renderPagination();
  }

  suppressVulnerability(item) {
    // Implementation for suppressing vulnerabilities
    console.log('Suppressing vulnerability:', item);
    // This would integrate with the backend API
  }

  exportVulnerability(item) {
    // Implementation for exporting vulnerability details
    console.log('Exporting vulnerability:', item);
    // This would trigger file download
  }

  analyzeDependency(item) {
    // Implementation for analyzing single dependency
    console.log('Analyzing dependency:', item);
    // This would trigger vulnerability analysis for the dependency
  }

  reset() {
    this.data = [];
    this.filteredData = [];
    this.currentPage = 1;
    this.sortColumn = null;
    this.sortDirection = 'asc';
    this.filters = {};
    
    this.renderTable();
    this.renderPagination();
  }

  destroy() {
    // Clean up event listeners
    if (this.options.sortable && this.thead) {
      const sortableHeaders = this.thead.querySelectorAll('.table-sortable');
      sortableHeaders.forEach(header => {
        DOMUtils.off(header, 'click');
      });
    }
    
    this.container = null;
    this.table = null;
    this.tbody = null;
    this.thead = null;
    this.data = [];
    this.filteredData = [];
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = VulnerabilityTableComponent;
}
