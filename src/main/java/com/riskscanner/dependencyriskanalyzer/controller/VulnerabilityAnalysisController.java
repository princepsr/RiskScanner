package com.riskscanner.dependencyriskanalyzer.controller;

import com.riskscanner.dependencyriskanalyzer.model.DependencyCoordinate;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.VulnerabilityFinding;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.VulnerabilityExplanation;
import com.riskscanner.dependencyriskanalyzer.service.vulnerability.VulnerabilityMatchingService;
import com.riskscanner.dependencyriskanalyzer.service.vulnerability.VulnerabilitySuppressionService;
import com.riskscanner.dependencyriskanalyzer.service.vulnerability.VulnerabilityExplanationService;
import com.riskscanner.dependencyriskanalyzer.service.vulnerability.FalsePositiveAnalyzer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * REST controller for vulnerability analysis with risk scoring and confidence levels.
 *
 * <p>Provides endpoints for analyzing vulnerabilities with transparent risk assessment,
 * confidence scoring, and suppression management.
 */
@RestController
@RequestMapping("/api/vulnerabilities")
public class VulnerabilityAnalysisController {

    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityAnalysisController.class);

    @Autowired
    private VulnerabilityMatchingService vulnerabilityMatchingService;

    @Autowired
    private VulnerabilitySuppressionService suppressionService;

    @Autowired
    private VulnerabilityExplanationService explanationService;

    /**
     * Analyzes vulnerabilities for a single dependency with risk scoring and AI explanations.
     *
     * @param groupId the Maven groupId
     * @param artifactId the Maven artifactId
     * @param version the version
     * @param buildTool the build tool (maven/gradle)
     * @param scope the dependency scope
     * @param dependencyDepth depth of dependency (0 = direct)
     * @param includeExplanations whether to include AI explanations
     * @return list of vulnerability findings with risk scores, confidence, and optional AI explanations
     */
    @GetMapping("/analyze")
    public ResponseEntity<VulnerabilityAnalysisResponse> analyzeVulnerability(
            @RequestParam String groupId,
            @RequestParam String artifactId,
            @RequestParam String version,
            @RequestParam String buildTool,
            @RequestParam(required = false) String scope,
            @RequestParam(defaultValue = "0") int dependencyDepth,
            @RequestParam(defaultValue = "false") boolean includeExplanations) {
        
        try {
            DependencyCoordinate dependency = new DependencyCoordinate(groupId, artifactId, version, buildTool, scope);
            
            // Use default analysis context
            FalsePositiveAnalyzer.AnalysisContext context = FalsePositiveAnalyzer.AnalysisContext.defaultContext();
            
            List<VulnerabilityFinding> findings = vulnerabilityMatchingService.getVulnerabilityFindings(
                dependency, dependencyDepth, context);
            
            // Generate AI explanations if requested
            Map<String, VulnerabilityExplanation> explanations = Map.of();
            if (includeExplanations) {
                explanations = generateExplanations(findings, List.of(dependency.toString()));
            }
            
            VulnerabilityAnalysisResponse response = new VulnerabilityAnalysisResponse(
                dependency, findings, explanations, "Analysis completed successfully");
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            logger.error("Failed to analyze vulnerability for {}:{}:{}", groupId, artifactId, version, e);
            return ResponseEntity.badRequest()
                .body(new VulnerabilityAnalysisResponse(null, List.of(), Map.of(), "Error: " + e.getMessage()));
        }
    }

    /**
     * Analyzes vulnerabilities for multiple dependencies with optional AI explanations.
     *
     * @param request request containing list of dependencies and their depths
     * @return map of dependencies to their vulnerability findings
     */
    @PostMapping("/analyze-batch")
    public ResponseEntity<BatchVulnerabilityAnalysisResponse> analyzeVulnerabilities(
            @RequestBody BatchVulnerabilityRequest request) {
        
        try {
            Map<DependencyCoordinate, List<VulnerabilityFinding>> findings = 
                vulnerabilityMatchingService.getVulnerabilityFindings(
                    request.getDependencies(), 
                    request.getDependencyDepths(),
                    FalsePositiveAnalyzer.AnalysisContext.defaultContext());
            
            // Generate AI explanations if requested
            Map<String, Map<String, VulnerabilityExplanation>> explanations = Map.of();
            if (request.isIncludeExplanations()) {
                explanations = generateBatchExplanations(findings);
            }
            
            BatchVulnerabilityAnalysisResponse response = new BatchVulnerabilityAnalysisResponse(
                findings, explanations, "Batch analysis completed successfully");
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            logger.error("Failed to analyze batch vulnerabilities", e);
            return ResponseEntity.badRequest()
                .body(new BatchVulnerabilityAnalysisResponse(null, Map.of(), "Error: " + e.getMessage()));
        }
    }

    /**
     * Generates AI explanations for vulnerability findings.
     */
    private Map<String, VulnerabilityExplanation> generateExplanations(List<VulnerabilityFinding> findings, List<String> dependencyPath) {
        Map<String, VulnerabilityExplanation> explanations = new java.util.concurrent.ConcurrentHashMap<>();
        
        findings.parallelStream().forEach(finding -> {
            Optional<VulnerabilityExplanation> explanation = explanationService.explainVulnerability(finding, dependencyPath);
            explanation.ifPresent(exp -> explanations.put(finding.getId(), exp));
        });
        
        return explanations;
    }

    /**
     * Generates AI explanations for batch analysis.
     */
    private Map<String, Map<String, VulnerabilityExplanation>> generateBatchExplanations(
            Map<DependencyCoordinate, List<VulnerabilityFinding>> findings) {
        
        Map<String, Map<String, VulnerabilityExplanation>> explanations = new java.util.concurrent.ConcurrentHashMap<>();
        
        findings.entrySet().parallelStream().forEach(entry -> {
            DependencyCoordinate dependency = entry.getKey();
            List<VulnerabilityFinding> dependencyFindings = entry.getValue();
            List<String> dependencyPath = List.of(dependency.toString());
            
            Map<String, VulnerabilityExplanation> dependencyExplanations = generateExplanations(dependencyFindings, dependencyPath);
            explanations.put(dependency.toString(), dependencyExplanations);
        });
        
        return explanations;
    }

    /**
     * Suppresses a vulnerability finding.
     *
     * @param request suppression request
     * @return updated vulnerability finding
     */
    @PostMapping("/suppress")
    public ResponseEntity<VulnerabilityFinding> suppressVulnerability(
            @RequestBody SuppressionRequest request) {
        
        try {
            // Create a finding object for suppression
            VulnerabilityFinding finding = VulnerabilityFinding.builder()
                .id(request.getFindingId())
                .dependency(request.getDependency())
                .vulnerability(null) // Not needed for suppression
                .rawSeverity(null)
                .riskScore(null)
                .confidenceLevel(null)
                .confidenceScore(0)
                .suppressed(false)
                .sources(List.of())
                .detectedAt(java.time.Instant.now())
                .build();
            
            VulnerabilityFinding suppressed = suppressionService.suppress(
                finding, request.getReason(), request.getSuppressedBy(), request.getJustification());
            
            return ResponseEntity.ok(suppressed);
            
        } catch (Exception e) {
            logger.error("Failed to suppress vulnerability {}", request.getFindingId(), e);
            return ResponseEntity.badRequest().build();
        }
    }

    /**
     * Unsupsupresses a vulnerability finding.
     *
     * @param findingId the ID of the finding to unsuppress
     * @param request unsuppression request
     * @return success response
     */
    @PostMapping("/unsuppress")
    public ResponseEntity<UnsuppressResponse> unsuppressVulnerability(
            @RequestParam String findingId,
            @RequestBody UnsuppressRequest request) {
        
        try {
            boolean success = suppressionService.unsuppress(findingId, request.getDependency(), request.getUnsuppressedBy());
            
            UnsuppressResponse response = new UnsuppressResponse(success, 
                success ? "Vulnerability unsuppressed successfully" : "Vulnerability not found or not suppressed");
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            logger.error("Failed to unsuppress vulnerability {}", findingId, e);
            return ResponseEntity.badRequest()
                .body(new UnsuppressResponse(false, "Error: " + e.getMessage()));
        }
    }

    /**
     * Gets the suppression audit log.
     *
     * @return list of audit entries
     */
    @GetMapping("/suppression-audit")
    public ResponseEntity<List<VulnerabilitySuppressionService.SuppressionAuditEntry>> getSuppressionAuditLog() {
        try {
            List<VulnerabilitySuppressionService.SuppressionAuditEntry> auditLog = suppressionService.getAuditLog();
            return ResponseEntity.ok(auditLog);
        } catch (Exception e) {
            logger.error("Failed to get suppression audit log", e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Gets all active suppressions.
     *
     * @return list of active suppression records
     */
    @GetMapping("/suppressions")
    public ResponseEntity<List<VulnerabilitySuppressionService.SuppressionRecord>> getActiveSuppressions() {
        try {
            List<VulnerabilitySuppressionService.SuppressionRecord> suppressions = suppressionService.getActiveSuppressions();
            return ResponseEntity.ok(suppressions);
        } catch (Exception e) {
            logger.error("Failed to get active suppressions", e);
            return ResponseEntity.internalServerError().build();
        }
    }

    // Response DTOs
    public static class VulnerabilityAnalysisResponse {
        private final DependencyCoordinate dependency;
        private final List<VulnerabilityFinding> findings;
        private final Map<String, VulnerabilityExplanation> explanations;
        private final String message;

        public VulnerabilityAnalysisResponse(DependencyCoordinate dependency, List<VulnerabilityFinding> findings, 
                                            Map<String, VulnerabilityExplanation> explanations, String message) {
            this.dependency = dependency;
            this.findings = findings;
            this.explanations = explanations;
            this.message = message;
        }

        public DependencyCoordinate getDependency() { return dependency; }
        public List<VulnerabilityFinding> getFindings() { return findings; }
        public Map<String, VulnerabilityExplanation> getExplanations() { return explanations; }
        public String getMessage() { return message; }
    }

    public static class BatchVulnerabilityAnalysisResponse {
        private final Map<DependencyCoordinate, List<VulnerabilityFinding>> findings;
        private final Map<String, Map<String, VulnerabilityExplanation>> explanations;
        private final String message;

        public BatchVulnerabilityAnalysisResponse(Map<DependencyCoordinate, List<VulnerabilityFinding>> findings,
                                                  Map<String, Map<String, VulnerabilityExplanation>> explanations, 
                                                  String message) {
            this.findings = findings;
            this.explanations = explanations;
            this.message = message;
        }

        public Map<DependencyCoordinate, List<VulnerabilityFinding>> getFindings() { return findings; }
        public Map<String, Map<String, VulnerabilityExplanation>> getExplanations() { return explanations; }
        public String getMessage() { return message; }
    }

    // Request DTOs
    public static class BatchVulnerabilityRequest {
        private List<DependencyCoordinate> dependencies;
        private Map<DependencyCoordinate, Integer> dependencyDepths;
        private boolean includeExplanations = false;

        public List<DependencyCoordinate> getDependencies() { return dependencies; }
        public void setDependencies(List<DependencyCoordinate> dependencies) { this.dependencies = dependencies; }

        public Map<DependencyCoordinate, Integer> getDependencyDepths() { return dependencyDepths; }
        public void setDependencyDepths(Map<DependencyCoordinate, Integer> dependencyDepths) { this.dependencyDepths = dependencyDepths; }

        public boolean isIncludeExplanations() { return includeExplanations; }
        public void setIncludeExplanations(boolean includeExplanations) { this.includeExplanations = includeExplanations; }
    }

    public static class SuppressionRequest {
        private String findingId;
        private DependencyCoordinate dependency;
        private String reason;
        private String suppressedBy;
        private String justification;

        public String getFindingId() { return findingId; }
        public void setFindingId(String findingId) { this.findingId = findingId; }

        public DependencyCoordinate getDependency() { return dependency; }
        public void setDependency(DependencyCoordinate dependency) { this.dependency = dependency; }

        public String getReason() { return reason; }
        public void setReason(String reason) { this.reason = reason; }

        public String getSuppressedBy() { return suppressedBy; }
        public void setSuppressedBy(String suppressedBy) { this.suppressedBy = suppressedBy; }

        public String getJustification() { return justification; }
        public void setJustification(String justification) { this.justification = justification; }
    }

    public static class UnsuppressRequest {
        private DependencyCoordinate dependency;
        private String unsuppressedBy;

        public DependencyCoordinate getDependency() { return dependency; }
        public void setDependency(DependencyCoordinate dependency) { this.dependency = dependency; }

        public String getUnsuppressedBy() { return unsuppressedBy; }
        public void setUnsuppressedBy(String unsuppressedBy) { this.unsuppressedBy = unsuppressedBy; }
    }

    public static class UnsuppressResponse {
        private final boolean success;
        private final String message;

        public UnsuppressResponse(boolean success, String message) {
            this.success = success;
            this.message = message;
        }

        public boolean isSuccess() { return success; }
        public String getMessage() { return message; }
    }
}
