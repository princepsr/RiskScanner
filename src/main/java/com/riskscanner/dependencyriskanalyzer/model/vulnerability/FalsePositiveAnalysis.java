package com.riskscanner.dependencyriskanalyzer.model.vulnerability;

import com.riskscanner.dependencyriskanalyzer.model.DependencyCoordinate;

import java.time.Instant;
import java.util.List;

/**
 * Result of false positive analysis for a vulnerability.
 *
 * <p>Contains the adjusted severity, reasoning for any downgrades,
 * and metadata about the analysis process.
 */
public class FalsePositiveAnalysis {

    private final DependencyCoordinate dependency;
    private final String vulnerabilityId;
    private final Severity originalSeverity;
    private final Severity adjustedSeverity;
    private final boolean downgraded;
    private final List<String> reasoning;
    private final Instant analyzedAt;
    private final AnalysisMetadata metadata;

    private FalsePositiveAnalysis(Builder builder) {
        this.dependency = builder.dependency;
        this.vulnerabilityId = builder.vulnerabilityId;
        this.originalSeverity = builder.originalSeverity;
        this.adjustedSeverity = builder.adjustedSeverity;
        this.downgraded = builder.downgraded;
        this.reasoning = List.copyOf(builder.reasoning);
        this.analyzedAt = builder.analyzedAt;
        this.metadata = builder.metadata;
    }

    /**
     * Creates a new builder for constructing FalsePositiveAnalysis instances.
     */
    public static Builder builder() {
        return new Builder();
    }

    // Getters
    public DependencyCoordinate getDependency() {
        return dependency;
    }

    public String getVulnerabilityId() {
        return vulnerabilityId;
    }

    public Severity getOriginalSeverity() {
        return originalSeverity;
    }

    public Severity getAdjustedSeverity() {
        return adjustedSeverity;
    }

    public boolean isDowngraded() {
        return downgraded;
    }

    public List<String> getReasoning() {
        return reasoning;
    }

    public Instant getAnalyzedAt() {
        return analyzedAt;
    }

    public AnalysisMetadata getMetadata() {
        return metadata;
    }

    /**
     * Gets the severity difference (how many levels downgraded).
     */
    public int getSeverityDifference() {
        return originalSeverity.ordinal() - adjustedSeverity.ordinal();
    }

    @Override
    public String toString() {
        return String.format("FalsePositiveAnalysis{dependency=%s, vulnerabilityId='%s', original=%s, adjusted=%s, downgraded=%s}",
            dependency, vulnerabilityId, originalSeverity, adjustedSeverity, downgraded);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        FalsePositiveAnalysis that = (FalsePositiveAnalysis) o;
        return dependency.equals(that.dependency) && vulnerabilityId.equals(that.vulnerabilityId);
    }

    @Override
    public int hashCode() {
        return dependency.hashCode() * 31 + vulnerabilityId.hashCode();
    }

    /**
     * Builder pattern for constructing FalsePositiveAnalysis instances.
     */
    public static class Builder {
        private DependencyCoordinate dependency;
        private String vulnerabilityId;
        private Severity originalSeverity;
        private Severity adjustedSeverity;
        private boolean downgraded;
        private List<String> reasoning = List.of();
        private Instant analyzedAt;
        private AnalysisMetadata metadata;

        public Builder dependency(DependencyCoordinate dependency) {
            this.dependency = dependency;
            return this;
        }

        public Builder vulnerabilityId(String vulnerabilityId) {
            this.vulnerabilityId = vulnerabilityId;
            return this;
        }

        public Builder originalSeverity(Severity originalSeverity) {
            this.originalSeverity = originalSeverity;
            return this;
        }

        public Builder adjustedSeverity(Severity adjustedSeverity) {
            this.adjustedSeverity = adjustedSeverity;
            return this;
        }

        public Builder downgraded(boolean downgraded) {
            this.downgraded = downgraded;
            return this;
        }

        public Builder reasoning(List<String> reasoning) {
            this.reasoning = reasoning;
            return this;
        }

        public Builder analyzedAt(Instant analyzedAt) {
            this.analyzedAt = analyzedAt;
            return this;
        }

        public Builder metadata(AnalysisMetadata metadata) {
            this.metadata = metadata;
            return this;
        }

        public FalsePositiveAnalysis build() {
            if (dependency == null) {
                throw new IllegalArgumentException("Dependency is required");
            }
            if (vulnerabilityId == null || vulnerabilityId.isBlank()) {
                throw new IllegalArgumentException("Vulnerability ID is required");
            }
            if (originalSeverity == null) {
                throw new IllegalArgumentException("Original severity is required");
            }
            if (adjustedSeverity == null) {
                throw new IllegalArgumentException("Adjusted severity is required");
            }
            if (analyzedAt == null) {
                this.analyzedAt = Instant.now();
            }
            if (metadata == null) {
                this.metadata = new AnalysisMetadata();
            }

            return new FalsePositiveAnalysis(this);
        }
    }

    /**
     * Metadata about the false positive analysis process.
     */
    public static class AnalysisMetadata {
        private final boolean testScope;
        private final boolean optionalDependency;
        private final boolean shadedOrRelocated;
        private final boolean unreachable;
        private final String analysisEngine;
        private final String version;

        public AnalysisMetadata() {
            this(false, false, false, false, "FalsePositiveAnalyzer", "1.0");
        }

        public AnalysisMetadata(boolean testScope, boolean optionalDependency, 
                               boolean shadedOrRelocated, boolean unreachable,
                               String analysisEngine, String version) {
            this.testScope = testScope;
            this.optionalDependency = optionalDependency;
            this.shadedOrRelocated = shadedOrRelocated;
            this.unreachable = unreachable;
            this.analysisEngine = analysisEngine;
            this.version = version;
        }

        public boolean isTestScope() { return testScope; }
        public boolean isOptionalDependency() { return optionalDependency; }
        public boolean isShadedOrRelocated() { return shadedOrRelocated; }
        public boolean isUnreachable() { return unreachable; }
        public String getAnalysisEngine() { return analysisEngine; }
        public String getVersion() { return version; }

        @Override
        public String toString() {
            return String.format("AnalysisMetadata{testScope=%s, optional=%s, shaded=%s, unreachable=%s}",
                testScope, optionalDependency, shadedOrRelocated, unreachable);
        }
    }
}
