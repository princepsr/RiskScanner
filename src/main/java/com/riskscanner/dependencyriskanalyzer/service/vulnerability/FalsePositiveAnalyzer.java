package com.riskscanner.dependencyriskanalyzer.service.vulnerability;

import com.riskscanner.dependencyriskanalyzer.model.DependencyCoordinate;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.FalsePositiveAnalysis;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.Severity;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.Vulnerability;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

/**
 * Service for analyzing potential false positives in vulnerability detection.
 *
 * <p>This analyzer considers various factors that may reduce the actual risk
 * of a vulnerability, such as dependency scope, optional dependencies, shaded
 * packages, and code reachability.
 */
@Service
public class FalsePositiveAnalyzer {

    private static final Logger logger = LoggerFactory.getLogger(FalsePositiveAnalyzer.class);

    // Common test scope identifiers
    private static final Set<String> TEST_SCOPES = Set.of("test", "test-compile", "test-runtime", "test-provided");
    
    // Common optional dependency patterns
    private static final Set<String> OPTIONAL_PATTERNS = Set.of("optional", "provided", "runtime");
    
    // Common shading/relocation patterns
    private static final Set<String> SHADING_PATTERNS = Set.of("shaded", "relocated", "shadow", "relocate");

    /**
     * Analyzes a vulnerability for potential false positive indicators.
     *
     * @param vulnerability the vulnerability to analyze
     * @param dependency the dependency containing the vulnerability
     * @param context additional context for analysis
     * @return analysis result with adjusted severity and reasoning
     */
    public FalsePositiveAnalysis analyze(Vulnerability vulnerability, DependencyCoordinate dependency, AnalysisContext context) {
        logger.debug("Analyzing vulnerability {} in dependency {} for false positives", 
            vulnerability.getId(), dependency);

        Severity originalSeverity = vulnerability.getSeverity();
        List<String> reasoning = new ArrayList<>();
        boolean downgraded = false;
        Severity adjustedSeverity = originalSeverity;

        // Analyze dependency scope
        boolean testScope = isTestScope(dependency, context);
        if (testScope) {
            reasoning.add("Dependency is in test scope - vulnerability only affects test code");
            adjustedSeverity = downgradeSeverity(adjustedSeverity, reasoning);
            downgraded = true;
        }

        // Analyze optional dependencies
        boolean optional = isOptionalDependency(dependency, context);
        if (optional) {
            reasoning.add("Dependency is optional - may not be included in final artifact");
            adjustedSeverity = downgradeSeverity(adjustedSeverity, reasoning);
            downgraded = true;
        }

        // Analyze shaded/relocated packages
        boolean shaded = isShadedOrRelocated(dependency, context);
        if (shaded) {
            reasoning.add("Dependency appears to be shaded or relocated - original package may not be exposed");
            adjustedSeverity = downgradeSeverity(adjustedSeverity, reasoning);
            downgraded = true;
        }

        // Analyze reachability
        boolean unreachable = isUnreachable(dependency, context);
        if (unreachable) {
            reasoning.add("Dependency code appears unreachable - vulnerability cannot be exploited");
            adjustedSeverity = downgradeSeverity(adjustedSeverity, reasoning);
            downgraded = true;
        }

        // Additional analysis based on vulnerability characteristics
        analyzeVulnerabilityCharacteristics(vulnerability, dependency, reasoning, context);

        // Build analysis metadata
        FalsePositiveAnalysis.AnalysisMetadata metadata = new FalsePositiveAnalysis.AnalysisMetadata(
            testScope, optional, shaded, unreachable, "FalsePositiveAnalyzer", "1.0"
        );

        logger.info("False positive analysis completed for {} in {}: {} -> {} (downgraded: {})",
            vulnerability.getId(), dependency, originalSeverity, adjustedSeverity, downgraded);

        return FalsePositiveAnalysis.builder()
            .dependency(dependency)
            .vulnerabilityId(vulnerability.getId())
            .originalSeverity(originalSeverity)
            .adjustedSeverity(adjustedSeverity)
            .downgraded(downgraded)
            .reasoning(reasoning)
            .metadata(metadata)
            .build();
    }

    /**
     * Analyzes multiple vulnerabilities for a dependency.
     */
    public List<FalsePositiveAnalysis> analyze(List<Vulnerability> vulnerabilities, DependencyCoordinate dependency, AnalysisContext context) {
        List<FalsePositiveAnalysis> results = new ArrayList<>();
        
        for (Vulnerability vulnerability : vulnerabilities) {
            try {
                FalsePositiveAnalysis analysis = analyze(vulnerability, dependency, context);
                results.add(analysis);
            } catch (Exception e) {
                logger.warn("Failed to analyze vulnerability {} for false positives: {}", 
                    vulnerability.getId(), e.getMessage());
                
                // Create a no-op analysis for failed analysis
                results.add(createNoOpAnalysis(vulnerability, dependency, e.getMessage()));
            }
        }
        
        return results;
    }

    /**
     * Checks if the dependency is in test scope.
     */
    private boolean isTestScope(DependencyCoordinate dependency, AnalysisContext context) {
        // Check dependency scope directly
        if (dependency.scope() != null && TEST_SCOPES.contains(dependency.scope().toLowerCase())) {
            return true;
        }

        // Check context for test scope information
        if (context.isTestScope()) {
            return true;
        }

        // Check if dependency is commonly used only in tests
        String artifactId = dependency.artifactId().toLowerCase();
        return artifactId.contains("test") || 
               artifactId.contains("junit") || 
               artifactId.contains("mockito") || 
               artifactId.contains("testng");
    }

    /**
     * Checks if the dependency is optional.
     */
    private boolean isOptionalDependency(DependencyCoordinate dependency, AnalysisContext context) {
        // Check dependency scope for optional indicators
        if (dependency.scope() != null && OPTIONAL_PATTERNS.contains(dependency.scope().toLowerCase())) {
            return true;
        }

        // Check context for optional dependency information
        if (context.isOptionalDependency()) {
            return true;
        }

        // Check if dependency is commonly optional
        String groupId = dependency.groupId().toLowerCase();
        String artifactId = dependency.artifactId().toLowerCase();
        
        return groupId.contains("optional") || 
               artifactId.contains("optional") ||
               context.hasOptionalMarker(dependency);
    }

    /**
     * Checks if the dependency is shaded or relocated.
     */
    private boolean isShadedOrRelocated(DependencyCoordinate dependency, AnalysisContext context) {
        // Check context for shading information
        if (context.isShadedOrRelocated()) {
            return true;
        }

        // Check for common shading patterns in dependency coordinates
        String groupId = dependency.groupId().toLowerCase();
        String artifactId = dependency.artifactId().toLowerCase();
        
        return SHADING_PATTERNS.stream().anyMatch(pattern -> 
            groupId.contains(pattern) || artifactId.contains(pattern)) ||
               context.hasShadingMarker(dependency);
    }

    /**
     * Checks if the dependency code is unreachable.
     */
    private boolean isUnreachable(DependencyCoordinate dependency, AnalysisContext context) {
        // Check context for reachability information
        if (context.isUnreachable()) {
            return true;
        }

        // Check if dependency is in provided scope (not included in runtime)
        if ("provided".equalsIgnoreCase(dependency.scope())) {
            return true;
        }

        // Check if dependency has no usage indicators
        return context.hasNoUsageIndicators(dependency);
    }

    /**
     * Analyzes vulnerability-specific characteristics for false positive indicators.
     */
    private void analyzeVulnerabilityCharacteristics(Vulnerability vulnerability, DependencyCoordinate dependency, 
                                                     List<String> reasoning, AnalysisContext context) {
        
        // Check if vulnerability requires specific configuration that may not be present
        if (requiresSpecificConfiguration(vulnerability) && !context.hasRequiredConfiguration(vulnerability)) {
            reasoning.add("Vulnerability requires specific configuration that may not be present");
        }

        // Check if vulnerability affects a version range that doesn't include our version
        if (vulnerability.getVersionRange().isPresent() && 
            !vulnerability.getVersionRange().get().includes(dependency.version())) {
            reasoning.add("Vulnerability version range does not include the actual dependency version");
        }

        // Check if vulnerability is in a component that's not used
        if (affectsUnusedComponent(vulnerability, context)) {
            reasoning.add("Vulnerability affects a component that is not used in this context");
        }
    }

    /**
     * Downgrades severity based on analysis factors.
     */
    private Severity downgradeSeverity(Severity currentSeverity, List<String> reasoning) {
        // Never downgrade below INFO
        if (currentSeverity == Severity.INFO) {
            return currentSeverity;
        }

        // Apply severity downgrade rules
        Severity newSeverity = currentSeverity;
        
        // Test scope: downgrade by 2 levels
        if (reasoning.stream().anyMatch(r -> r.contains("test scope"))) {
            newSeverity = downgradeByLevels(newSeverity, 2);
        }
        
        // Optional dependency: downgrade by 1 level
        if (reasoning.stream().anyMatch(r -> r.contains("optional"))) {
            newSeverity = downgradeByLevels(newSeverity, 1);
        }
        
        // Shaded/Relocated: downgrade by 1 level
        if (reasoning.stream().anyMatch(r -> r.contains("shaded") || r.contains("relocated"))) {
            newSeverity = downgradeByLevels(newSeverity, 1);
        }
        
        // Unreachable: downgrade by 2 levels
        if (reasoning.stream().anyMatch(r -> r.contains("unreachable"))) {
            newSeverity = downgradeByLevels(newSeverity, 2);
        }

        return newSeverity;
    }

    /**
     * Downgrades severity by the specified number of levels.
     */
    private Severity downgradeByLevels(Severity severity, int levels) {
        Severity[] values = Severity.values();
        int currentIndex = severity.ordinal();
        int newIndex = Math.min(currentIndex + levels, values.length - 1);
        return values[newIndex];
    }

    /**
     * Checks if vulnerability requires specific configuration.
     */
    private boolean requiresSpecificConfiguration(Vulnerability vulnerability) {
        String description = vulnerability.getDescription().toLowerCase();
        return description.contains("configuration") || 
               description.contains("enabled") || 
               description.contains("setting") ||
               description.contains("when");
    }

    /**
     * Checks if vulnerability affects an unused component.
     */
    private boolean affectsUnusedComponent(Vulnerability vulnerability, AnalysisContext context) {
        String description = vulnerability.getDescription().toLowerCase();
        return description.contains("module") || 
               description.contains("component") ||
               description.contains("feature");
    }

    /**
     * Creates a no-op analysis when analysis fails.
     */
    private FalsePositiveAnalysis createNoOpAnalysis(Vulnerability vulnerability, DependencyCoordinate dependency, String errorMessage) {
        return FalsePositiveAnalysis.builder()
            .dependency(dependency)
            .vulnerabilityId(vulnerability.getId())
            .originalSeverity(vulnerability.getSeverity())
            .adjustedSeverity(vulnerability.getSeverity())
            .downgraded(false)
            .reasoning(List.of("Analysis failed: " + errorMessage))
            .metadata(new FalsePositiveAnalysis.AnalysisMetadata())
            .build();
    }

    /**
     * Context information for false positive analysis.
     */
    public static class AnalysisContext {
        private final boolean testScope;
        private final boolean optionalDependency;
        private final boolean shadedOrRelocated;
        private final boolean unreachable;

        public AnalysisContext(boolean testScope, boolean optionalDependency, 
                             boolean shadedOrRelocated, boolean unreachable) {
            this.testScope = testScope;
            this.optionalDependency = optionalDependency;
            this.shadedOrRelocated = shadedOrRelocated;
            this.unreachable = unreachable;
        }

        public boolean isTestScope() { return testScope; }
        public boolean isOptionalDependency() { return optionalDependency; }
        public boolean isShadedOrRelocated() { return shadedOrRelocated; }
        public boolean isUnreachable() { return unreachable; }

        public boolean hasOptionalMarker(DependencyCoordinate dependency) { return false; }
        public boolean hasShadingMarker(DependencyCoordinate dependency) { return false; }
        public boolean hasNoUsageIndicators(DependencyCoordinate dependency) { return false; }
        public boolean hasRequiredConfiguration(Vulnerability vulnerability) { return false; }

        /**
         * Creates a default context with no false positive indicators.
         */
        public static AnalysisContext defaultContext() {
            return new AnalysisContext(false, false, false, false);
        }

        /**
         * Creates a context for test dependencies.
         */
        public static AnalysisContext testContext() {
            return new AnalysisContext(true, false, false, false);
        }

        /**
         * Creates a context for optional dependencies.
         */
        public static AnalysisContext optionalContext() {
            return new AnalysisContext(false, true, false, false);
        }
    }
}
