package com.riskscanner.dependencyriskanalyzer.service.vulnerability;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.riskscanner.dependencyriskanalyzer.model.DependencyCoordinate;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.Vulnerability;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Service for caching vulnerability data to support offline operation.
 *
 * <p>This service provides:
 * <ul>
 *   <li>Persistent caching of vulnerability data to local filesystem</li>
 *   <li>Cache expiration and cleanup</li>
 *   <li>Offline fallback when network providers are unavailable</li>
 *   <li>Cache statistics and management</li>
 * </ul>
 */
@Service
public class VulnerabilityCacheService {

    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityCacheService.class);
    
    private static final String CACHE_DIR = System.getProperty("user.home") + "/.buildaegis/vulnerability-cache";
    private static final long CACHE_EXPIRY_HOURS = 24; // Cache expires after 24 hours
    
    private final ObjectMapper objectMapper;
    private final Map<String, List<Vulnerability>> memoryCache = new ConcurrentHashMap<>();
    private final Path cacheDirectory;
    
    public VulnerabilityCacheService() {
        this.objectMapper = new ObjectMapper();
        this.cacheDirectory = Path.of(CACHE_DIR);
        
        try {
            // Create cache directory if it doesn't exist
            Files.createDirectories(cacheDirectory);
            logger.info("Vulnerability cache directory: {}", cacheDirectory);
        } catch (IOException e) {
            logger.error("Failed to create cache directory: {}", e.getMessage());
        }
    }
    
    /**
     * Gets cached vulnerabilities for the given dependency.
     *
     * @param dependency the dependency to check
     * @return cached vulnerabilities, or empty list if none found or cache expired
     */
    public List<Vulnerability> getCachedVulnerabilities(DependencyCoordinate dependency) {
        String cacheKey = buildCacheKey(dependency);
        
        // Check memory cache first
        List<Vulnerability> cached = memoryCache.get(cacheKey);
        if (cached != null) {
            logger.debug("Found cached vulnerabilities in memory for {}", dependency);
            return new ArrayList<>(cached);
        }
        
        // Check file cache
        try {
            Path cacheFile = getCacheFile(dependency);
            if (Files.exists(cacheFile)) {
                // Check if cache is expired
                Instant lastModified = Files.getLastModifiedTime(cacheFile).toInstant();
                if (lastModified.plus(CACHE_EXPIRY_HOURS, ChronoUnit.HOURS).isAfter(Instant.now())) {
                    // Load from file
                    cached = loadFromFile(cacheFile);
                    if (cached != null) {
                        // Store in memory cache for faster access
                        memoryCache.put(cacheKey, cached);
                        logger.debug("Loaded {} cached vulnerabilities from file for {}", cached.size(), dependency);
                        return new ArrayList<>(cached);
                    }
                } else {
                    logger.debug("Cache expired for {}, removing file", dependency);
                    Files.deleteIfExists(cacheFile);
                }
            }
        } catch (IOException e) {
            logger.warn("Failed to load cached vulnerabilities for {}: {}", dependency, e.getMessage());
        }
        
        return List.of();
    }
    
    /**
     * Caches vulnerabilities for the given dependency.
     *
     * @param dependency the dependency
     * @param vulnerabilities the vulnerabilities to cache
     */
    public void cacheVulnerabilities(DependencyCoordinate dependency, List<Vulnerability> vulnerabilities) {
        if (vulnerabilities == null || vulnerabilities.isEmpty()) {
            return;
        }
        
        String cacheKey = buildCacheKey(dependency);
        
        // Store in memory cache
        memoryCache.put(cacheKey, new ArrayList<>(vulnerabilities));
        
        // Store in file cache
        try {
            Path cacheFile = getCacheFile(dependency);
            saveToFile(cacheFile, vulnerabilities);
            logger.debug("Cached {} vulnerabilities for {}", vulnerabilities.size(), dependency);
        } catch (IOException e) {
            logger.warn("Failed to cache vulnerabilities for {}: {}", dependency, e.getMessage());
        }
    }
    
    /**
     * Clears all cached vulnerability data.
     */
    public void clearCache() {
        // Clear memory cache
        memoryCache.clear();
        
        // Clear file cache
        try {
            if (Files.exists(cacheDirectory)) {
                Files.walk(cacheDirectory)
                    .filter(Files::isRegularFile)
                    .forEach(file -> {
                        try {
                            Files.delete(file);
                        } catch (IOException e) {
                            logger.warn("Failed to delete cache file {}: {}", file, e.getMessage());
                        }
                    });
            }
            logger.info("Cleared all vulnerability cache data");
        } catch (IOException e) {
            logger.error("Failed to clear file cache: {}", e.getMessage());
        }
    }
    
    /**
     * Cleans up expired cache entries.
     */
    public void cleanupExpiredCache() {
        try {
            if (Files.exists(cacheDirectory)) {
                Instant cutoff = Instant.now().minus(CACHE_EXPIRY_HOURS, ChronoUnit.HOURS);
                
                Files.walk(cacheDirectory)
                    .filter(Files::isRegularFile)
                    .forEach(file -> {
                        try {
                            Instant lastModified = Files.getLastModifiedTime(file).toInstant();
                            if (lastModified.isBefore(cutoff)) {
                                Files.delete(file);
                                logger.debug("Deleted expired cache file: {}", file);
                            }
                        } catch (IOException e) {
                            logger.warn("Failed to process cache file {}: {}", file, e.getMessage());
                        }
                    });
            }
            
            // Also clean memory cache of expired entries
            memoryCache.entrySet().removeIf(entry -> {
                // For memory cache, we don't have timestamps, so we keep it
                // Memory cache will be cleared when the application restarts
                return false;
            });
            
            logger.info("Cleaned up expired cache entries");
            
        } catch (IOException e) {
            logger.error("Failed to cleanup expired cache: {}", e.getMessage());
        }
    }
    
    /**
     * Gets cache statistics.
     */
    public CacheStatistics getCacheStatistics() {
        int memoryCacheSize = memoryCache.size();
        int memoryCacheVulnerabilities = memoryCache.values().stream()
            .mapToInt(List::size)
            .sum();
        
        int fileCacheSize = 0;
        int fileCacheVulnerabilities = 0;
        long totalCacheSize = 0;
        
        try {
            if (Files.exists(cacheDirectory)) {
                List<Path> cacheFiles = Files.walk(cacheDirectory)
                    .filter(Files::isRegularFile)
                    .toList();
                
                fileCacheSize = cacheFiles.size();
                
                for (Path cacheFile : cacheFiles) {
                    try {
                        List<Vulnerability> vulns = loadFromFile(cacheFile);
                        if (vulns != null) {
                            fileCacheVulnerabilities += vulns.size();
                        }
                        totalCacheSize += Files.size(cacheFile);
                    } catch (IOException e) {
                        logger.debug("Failed to read cache file {}: {}", cacheFile, e.getMessage());
                    }
                }
            }
        } catch (IOException e) {
            logger.warn("Failed to calculate file cache statistics: {}", e.getMessage());
        }
        
        return new CacheStatistics(
            memoryCacheSize, memoryCacheVulnerabilities,
            fileCacheSize, fileCacheVulnerabilities,
            totalCacheSize
        );
    }
    
    /**
     * Checks if cache is available for the given dependency.
     */
    public boolean hasCachedData(DependencyCoordinate dependency) {
        String cacheKey = buildCacheKey(dependency);
        
        // Check memory cache
        if (memoryCache.containsKey(cacheKey)) {
            return true;
        }
        
        // Check file cache
        try {
            Path cacheFile = getCacheFile(dependency);
            if (Files.exists(cacheFile)) {
                Instant lastModified = Files.getLastModifiedTime(cacheFile).toInstant();
                return lastModified.plus(CACHE_EXPIRY_HOURS, ChronoUnit.HOURS).isAfter(Instant.now());
            }
        } catch (IOException e) {
            logger.debug("Failed to check cache file for {}: {}", dependency, e.getMessage());
        }
        
        return false;
    }
    
    /**
     * Builds cache key for dependency.
     */
    private String buildCacheKey(DependencyCoordinate dependency) {
        return String.format("%s:%s:%s:%s", 
            dependency.groupId(), dependency.artifactId(), 
            dependency.version(), dependency.buildTool());
    }
    
    /**
     * Gets cache file path for dependency.
     */
    private Path getCacheFile(DependencyCoordinate dependency) {
        String filename = buildCacheKey(dependency).replaceAll("[^a-zA-Z0-9._-]", "_") + ".json";
        return cacheDirectory.resolve(filename);
    }
    
    /**
     * Saves vulnerabilities to file.
     */
    private void saveToFile(Path file, List<Vulnerability> vulnerabilities) throws IOException {
        objectMapper.writeValue(file.toFile(), vulnerabilities);
    }
    
    /**
     * Loads vulnerabilities from file.
     */
    @SuppressWarnings("unchecked")
    private List<Vulnerability> loadFromFile(Path file) throws IOException {
        return objectMapper.readValue(file.toFile(), List.class);
    }
    
    /**
     * Cache statistics holder.
     */
    public static class CacheStatistics {
        private final int memoryCacheEntries;
        private final int memoryCacheVulnerabilities;
        private final int fileCacheEntries;
        private final int fileCacheVulnerabilities;
        private final long totalCacheSizeBytes;
        
        public CacheStatistics(int memoryCacheEntries, int memoryCacheVulnerabilities,
                             int fileCacheEntries, int fileCacheVulnerabilities,
                             long totalCacheSizeBytes) {
            this.memoryCacheEntries = memoryCacheEntries;
            this.memoryCacheVulnerabilities = memoryCacheVulnerabilities;
            this.fileCacheEntries = fileCacheEntries;
            this.fileCacheVulnerabilities = fileCacheVulnerabilities;
            this.totalCacheSizeBytes = totalCacheSizeBytes;
        }
        
        public int getMemoryCacheEntries() { return memoryCacheEntries; }
        public int getMemoryCacheVulnerabilities() { return memoryCacheVulnerabilities; }
        public int getFileCacheEntries() { return fileCacheEntries; }
        public int getFileCacheVulnerabilities() { return fileCacheVulnerabilities; }
        public long getTotalCacheSizeBytes() { return totalCacheSizeBytes; }
        
        public String getTotalCacheSizeHumanReadable() {
            if (totalCacheSizeBytes < 1024) {
                return totalCacheSizeBytes + " B";
            } else if (totalCacheSizeBytes < 1024 * 1024) {
                return String.format("%.1f KB", totalCacheSizeBytes / 1024.0);
            } else if (totalCacheSizeBytes < 1024 * 1024 * 1024) {
                return String.format("%.1f MB", totalCacheSizeBytes / (1024.0 * 1024));
            } else {
                return String.format("%.1f GB", totalCacheSizeBytes / (1024.0 * 1024 * 1024));
            }
        }
    }
}
