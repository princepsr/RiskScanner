package com.riskscanner.dependencyriskanalyzer.service.vulnerability;

import com.riskscanner.dependencyriskanalyzer.model.DependencyCoordinate;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.VulnerabilityFinding;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.VulnerabilityExplanation;
import com.riskscanner.dependencyriskanalyzer.service.AiSettingsService;
import com.riskscanner.dependencyriskanalyzer.service.ai.AiClient;
import com.riskscanner.dependencyriskanalyzer.service.ai.AiClientFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

/**
 * Service for generating AI-powered explanations of vulnerability findings.
 *
 * <p>Uses AI to provide human-friendly explanations of vulnerabilities,
 * their real-world impact, and remediation options. All AI output is clearly
 * marked as advisory and does not modify core vulnerability data.
 */
@Service
public class VulnerabilityExplanationService {

    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityExplanationService.class);

    @Autowired
    private AiSettingsService aiSettingsService;

    @Autowired(required = false)
    private AiClientFactory aiClientFactory;

    /**
     * Generates an AI explanation for a vulnerability finding.
     *
     * @param finding the vulnerability finding to explain
     * @param dependencyPath the dependency path from root
     * @return optional explanation (empty if AI is not configured or fails)
     */
    public Optional<VulnerabilityExplanation> explainVulnerability(VulnerabilityFinding finding, List<String> dependencyPath) {
        if (!isAiConfigured()) {
            logger.debug("AI not configured, skipping explanation for {}", finding.getId());
            return Optional.empty();
        }

        try {
            String prompt = buildExplanationPrompt(finding, dependencyPath);
            AiClient aiClient = aiClientFactory.getClient();
            
            String aiResponse = aiClient.generateCompletion(prompt);
            VulnerabilityExplanation explanation = parseAiResponse(aiResponse, finding);
            
            logger.info("Generated AI explanation for vulnerability {}", finding.getId());
            return Optional.of(explanation);
            
        } catch (Exception e) {
            logger.warn("Failed to generate AI explanation for {}: {}", finding.getId(), e.getMessage());
            return Optional.empty();
        }
    }

    /**
     * Generates explanations for multiple vulnerability findings.
     *
     * @param findings list of vulnerability findings
     * @param dependencyPaths map of finding ID to dependency path
     * @return list of explanations (empty for failed AI calls)
     */
    public List<VulnerabilityExplanation> explainVulnerabilities(List<VulnerabilityFinding> findings,
                                                               java.util.Map<String, List<String>> dependencyPaths) {
        return findings.parallelStream()
            .map(finding -> explainVulnerability(finding, dependencyPaths.getOrDefault(finding.getId(), List.of())))
            .filter(Optional::isPresent)
            .map(Optional::get)
            .toList();
    }

    /**
     * Checks if AI is properly configured and available.
     */
    private boolean isAiConfigured() {
        try {
            return aiSettingsService.getSettings().configured() && aiClientFactory != null;
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * Builds the AI prompt for vulnerability explanation.
     */
    private String buildExplanationPrompt(VulnerabilityFinding finding, List<String> dependencyPath) {
        StringBuilder prompt = new StringBuilder();
        
        prompt.append("You are a cybersecurity expert explaining a software vulnerability to a development team.\n\n");
        prompt.append("VULNERABILITY DETAILS:\n");
        prompt.append("- ID: ").append(finding.getId()).append("\n");
        prompt.append("- Title: ").append(finding.getVulnerability().getTitle()).append("\n");
        prompt.append("- Severity: ").append(finding.getRawSeverity()).append("\n");
        prompt.append("- Risk Score: ").append(finding.getRiskScore().getScore()).append(" (").append(finding.getRiskScore().getRiskLevel()).append(")\n");
        prompt.append("- Confidence: ").append(finding.getConfidenceLevel()).append(" (").append(finding.getConfidenceScore()).append("/100)\n");
        prompt.append("- Description: ").append(finding.getVulnerability().getDescription()).append("\n");
        
        if (!finding.getVulnerability().getReferences().isEmpty()) {
            prompt.append("- References: ").append(String.join(", ", finding.getVulnerability().getReferences())).append("\n");
        }
        
        prompt.append("\nDEPENDENCY CONTEXT:\n");
        prompt.append("- Group ID: ").append(finding.getDependency().groupId()).append("\n");
        prompt.append("- Artifact ID: ").append(finding.getDependency().artifactId()).append("\n");
        prompt.append("- Version: ").append(finding.getDependency().version()).append("\n");
        prompt.append("- Scope: ").append(finding.getDependency().scope()).append("\n");
        
        if (!dependencyPath.isEmpty()) {
            prompt.append("- Dependency Path: ").append(String.join(" -> ", dependencyPath)).append("\n");
        }
        
        prompt.append("\nTASK:\n");
        prompt.append("Please provide a clear, human-friendly explanation that covers:\n");
        prompt.append("1. WHY this vulnerability exists in this specific dependency\n");
        prompt.append("2. WHAT the real-world impact could be if exploited\n");
        prompt.append("3. HOW an attacker could potentially exploit this\n");
        prompt.append("4. WHAT high-level remediation options are available\n");
        prompt.append("5. WHEN this should be prioritized (consider the risk score and confidence)\n\n");
        
        prompt.append("GUIDELINES:\n");
        prompt.append("- Be specific to this vulnerability and dependency\n");
        prompt.append("- Use clear, non-technical language where possible\n");
        prompt.append("- Focus on practical impact and actionable advice\n");
        prompt.append("- Keep explanations concise but comprehensive\n");
        prompt.append("- Structure your response with clear headings\n");
        prompt.append("- Include confidence level considerations in your recommendations\n\n");
        
        prompt.append("Format your response as JSON with these fields:\n");
        prompt.append("{\n");
        prompt.append("  \"whyItExists\": \"explanation of why vulnerability exists\",\n");
        prompt.append("  \"realWorldImpact\": \"description of potential impact\",\n");
        prompt.append("  \"exploitationScenario\": \"how it could be exploited\",\n");
        prompt.append("  \"remediationOptions\": [\"option1\", \"option2\", \"option3\"],\n");
        prompt.append("  \"priorityRecommendation\": \"when and how to prioritize\",\n");
        prompt.append("  \"additionalContext\": \"any other relevant information\"\n");
        prompt.append("}\n\n");
        
        prompt.append("IMPORTANT: This is advisory information only. The system maintains objective risk scores independently.");
        
        return prompt.toString();
    }

    /**
     * Parses the AI response into a structured explanation.
     */
    private VulnerabilityExplanation parseAiResponse(String aiResponse, VulnerabilityFinding finding) {
        try {
            // Try to parse as JSON first
            if (aiResponse.trim().startsWith("{")) {
                // Simple JSON parsing - in production, use proper JSON library
                return parseJsonExplanation(aiResponse, finding);
            }
            
            // Fallback to text parsing
            return parseTextExplanation(aiResponse, finding);
            
        } catch (Exception e) {
            logger.warn("Failed to parse AI response for {}: {}", finding.getId(), e.getMessage());
            return createFallbackExplanation(finding, "Failed to parse AI response");
        }
    }

    /**
     * Parses JSON response from AI.
     */
    private VulnerabilityExplanation parseJsonExplanation(String jsonResponse, VulnerabilityFinding finding) {
        // Simple JSON parsing - in production, use Jackson or similar
        String whyItExists = extractJsonField(jsonResponse, "whyItExists");
        String realWorldImpact = extractJsonField(jsonResponse, "realWorldImpact");
        String exploitationScenario = extractJsonField(jsonResponse, "exploitationScenario");
        String priorityRecommendation = extractJsonField(jsonResponse, "priorityRecommendation");
        String additionalContext = extractJsonField(jsonResponse, "additionalContext");
        
        List<String> remediationOptions = extractJsonArray(jsonResponse, "remediationOptions");
        
        return new VulnerabilityExplanation(
            finding.getId(),
            whyItExists,
            realWorldImpact,
            exploitationScenario,
            remediationOptions,
            priorityRecommendation,
            additionalContext,
            "AI-Generated Explanation",
            java.time.Instant.now()
        );
    }

    /**
     * Parses text response from AI.
     */
    private VulnerabilityExplanation parseTextExplanation(String textResponse, VulnerabilityFinding finding) {
        // Simple text parsing - look for key sections
        String[] sections = textResponse.split("\n\n");
        
        String whyItExists = "AI explanation available in full response";
        String realWorldImpact = "AI explanation available in full response";
        String exploitationScenario = "AI explanation available in full response";
        String priorityRecommendation = "Review AI-generated explanation for prioritization guidance";
        String additionalContext = textResponse.length() > 500 ? textResponse.substring(0, 500) + "..." : textResponse;
        
        return new VulnerabilityExplanation(
            finding.getId(),
            whyItExists,
            realWorldImpact,
            exploitationScenario,
            List.of("Review AI-generated explanation for detailed remediation options"),
            priorityRecommendation,
            additionalContext,
            "AI-Generated Explanation",
            java.time.Instant.now()
        );
    }

    /**
     * Creates a fallback explanation when AI parsing fails.
     */
    private VulnerabilityExplanation createFallbackExplanation(VulnerabilityFinding finding, String reason) {
        return new VulnerabilityExplanation(
            finding.getId(),
            "AI explanation unavailable: " + reason,
            "Review vulnerability details and references for impact information",
            "Consult security team for exploitation scenarios",
            List.of("Update to fixed version", "Apply security patches", "Review alternative libraries"),
            "Prioritize based on risk score: " + finding.getRiskScore().getScore(),
            "AI explanation generation failed. Please review the vulnerability details manually.",
            "AI Explanation Failed",
            java.time.Instant.now()
        );
    }

    /**
     * Simple JSON field extraction.
     */
    private String extractJsonField(String json, String fieldName) {
        String pattern = "\"" + fieldName + "\"\\s*:\\s*\"([^\"]+)\"";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern);
        java.util.regex.Matcher m = p.matcher(json);
        return m.find() ? m.group(1) : "Not available";
    }

    /**
     * Simple JSON array extraction.
     */
    private List<String> extractJsonArray(String json, String fieldName) {
        String pattern = "\"" + fieldName + "\"\\s*:\\s*\\[([^\\]]+)\\]";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern);
        java.util.regex.Matcher m = p.matcher(json);
        
        if (m.find()) {
            String arrayContent = m.group(1);
            return java.util.Arrays.stream(arrayContent.split(","))
                .map(s -> s.trim().replaceAll("\"", ""))
                .filter(s -> !s.isEmpty())
                .toList();
        }
        
        return List.of("Not available");
    }
}
