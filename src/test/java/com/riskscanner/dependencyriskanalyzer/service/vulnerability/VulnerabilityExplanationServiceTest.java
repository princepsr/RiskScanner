package com.riskscanner.dependencyriskanalyzer.service.vulnerability;

import com.riskscanner.dependencyriskanalyzer.model.DependencyCoordinate;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.Severity;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.Vulnerability;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.VulnerabilityExplanation;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.VulnerabilitySource;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.VulnerabilityFinding;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.RiskScore;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.ConfidenceLevel;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@SpringBootTest
public class VulnerabilityExplanationServiceTest {

    @Mock
    private com.riskscanner.dependencyriskanalyzer.service.AiSettingsService aiSettingsService;

    @Mock
    private com.riskscanner.dependencyriskanalyzer.service.ai.AiClientFactory aiClientFactory;

    @Mock
    private com.riskscanner.dependencyriskanalyzer.service.ai.AiClient aiClient;

    private VulnerabilityExplanationService explanationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        explanationService = new VulnerabilityExplanationService();
    }

    @Test
    void testExplainVulnerability_WhenAiNotConfigured_ReturnsEmpty() {
        // Arrange
        VulnerabilityFinding finding = createTestFinding();
        List<String> dependencyPath = List.of("root:app:dependency");

        // Act
        Optional<VulnerabilityExplanation> result = explanationService.explainVulnerability(finding, dependencyPath);

        // Assert
        assertFalse(result.isPresent());
    }

    @Test
    void testExplainVulnerabilities_BatchProcessing() {
        // Arrange
        List<VulnerabilityFinding> findings = List.of(createTestFinding(), createTestFinding());

        // Act
        List<VulnerabilityExplanation> results = explanationService.explainVulnerabilities(findings, 
            java.util.Map.of("root:app", List.of("root:app")));

        // Assert - Should return empty list when AI is not configured
        assertEquals(0, results.size());
    }

    private VulnerabilityFinding createTestFinding() {
        Vulnerability vulnerability = Vulnerability.builder()
            .id("CVE-2024-TEST")
            .source(VulnerabilitySource.NVD)
            .title("Test Vulnerability")
            .description("A test vulnerability for unit testing")
            .severity(Severity.HIGH)
            .affectedVersions(List.of("1.0.0", "1.1.0"))
            .build();

        RiskScore riskScore = new RiskScore(85, "High risk due to test vulnerability");

        DependencyCoordinate dependency = new DependencyCoordinate(
            "com.example", "test-library", "1.0.0", "maven", "compile"
        );

        return VulnerabilityFinding.builder()
            .id("CVE-2024-TEST:com.example:test-library")
            .dependency(dependency)
            .vulnerability(vulnerability)
            .rawSeverity(Severity.HIGH)
            .riskScore(riskScore)
            .confidenceLevel(ConfidenceLevel.HIGH)
            .confidenceScore(90)
            .suppressed(false)
            .sources(List.of("NVD"))
            .detectedAt(java.time.Instant.now())
            .build();
    }
}
